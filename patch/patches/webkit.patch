Index: Source/WebCore/WebCore.gyp/WebCore.gyp
===================================================================
--- Source/WebCore/WebCore.gyp/WebCore.gyp	(revision 0)
+++ Source/WebCore/WebCore.gyp/WebCore.gyp	(working copy)
@@ -2064,6 +2064,7 @@
       'target_name': 'webcore_remaining',
       'type': 'static_library',
       'dependencies': [
+        '<(chromium_src_dir)/third_party/node/node.gyp:node',
         '<(chromium_src_dir)/third_party/v8-i18n/build/all.gyp:v8-i18n',
         'webcore_prerequisites',
       ],
Index: Source/WebCore/bindings/v8/WorkerScriptController.cpp
===================================================================
--- Source/WebCore/bindings/v8/WorkerScriptController.cpp	(revision 0)
+++ Source/WebCore/bindings/v8/WorkerScriptController.cpp	(working copy)
@@ -50,11 +50,27 @@
 
 #if PLATFORM(CHROMIUM)
 #include <public/Platform.h>
+#include <public/WebURL.h>
 #include <public/WebWorkerRunLoop.h>
+#include <public/WebWorkerScriptObserver.h>
 #endif
 
+#include "node.h"
+#include "node_vars.h"
+#include "node_javascript.h"
+
 namespace WebCore {
 
+namespace {
+
+static Vector<WebKit::WebWorkerScriptObserver*>& observerVector()
+{
+    AtomicallyInitializedStatic(Vector<WebKit::WebWorkerScriptObserver*>&, observers = *new Vector<WebKit::WebWorkerScriptObserver*>);
+    return observers;
+}
+
+}  // namespace
+
 WorkerScriptController::WorkerScriptController(WorkerContext* workerContext)
     : m_workerContext(workerContext)
     , m_isolate(v8::Isolate::New())
@@ -72,6 +88,8 @@ WorkerScriptController::WorkerScriptController(WorkerContext* workerContext)
 WorkerScriptController::~WorkerScriptController()
 {
     m_domDataStore.clear();
+    if (!m_context.isEmpty())
+        notifyWillReleaseWorkerScriptContext();
 #if PLATFORM(CHROMIUM)
     // The corresponding call to didStartWorkerRunLoop is in
     // WorkerThread::workerThread().
@@ -82,6 +100,7 @@ WorkerScriptController::~WorkerScriptController()
     V8PerIsolateData::dispose(m_isolate);
     m_isolate->Exit();
     m_isolate->Dispose();
+    node::globals_free();
 }
 
 void WorkerScriptController::disposeContext()
@@ -100,6 +119,9 @@ bool WorkerScriptController::initializeContextIfNeeded()
     if (m_context.isEmpty())
         return false;
 
+    // Force to wrap whole runloop in context.
+    m_context.get()->Enter();
+
     // Starting from now, use local context only.
     v8::Local<v8::Context> context = v8::Local<v8::Context>::New(m_context.get());
 
@@ -133,6 +155,34 @@ bool WorkerScriptController::initializeContextIfNeeded()
     v8::Handle<v8::Object> globalObject = v8::Handle<v8::Object>::Cast(m_context->Global()->GetPrototype());
     globalObject->SetPrototype(jsWorkerContext);
 
+    // Create the process object.
+    int argc = 1;
+    char* argv[] = { const_cast<char*>("node") };
+    v8::Local<v8::FunctionTemplate> process_template = v8::FunctionTemplate::New();
+    process_template->SetClassName(v8::String::NewSymbol("process"));
+    v8::Local<v8::Object> process = process_template->GetFunction()->NewInstance();
+    node::SetupProcessObject(process, argc, argv, true);
+
+    // The initialize script
+    v8::TryCatch try_catch;
+
+    v8::Local<v8::Script> script = v8::Script::Compile(
+        node::CefodeMainSource(), v8::String::New("cefode.js"));
+    v8::Local<v8::Value> result = script->Run();
+
+    v8::Handle<v8::Value> args[3] = {
+        v8::Local<v8::Value>::New(process),
+        v8String(m_workerContext->url().path()),
+        v8::Boolean::New(true)
+    };
+    v8::Local<v8::Function>::Cast(result)->Call(context->Global(), 3, args);
+    if (try_catch.HasCaught()) {
+      v8::String::Utf8Value trace(try_catch.StackTrace());
+      fprintf(stderr, "%s\n", *trace);
+    }
+
+    notifyDidCreateWorkerScriptContext();
+
     return true;
 }
 
@@ -256,6 +306,39 @@ WorkerScriptController* WorkerScriptController::controllerForContext()
     return workerContext->script();
 }
 
+void WorkerScriptController::addObserver(WebKit::WebWorkerScriptObserver* observer)
+{
+    if (WebCore::WorkerThread::workerThreadCount() > 0)
+      return;
+
+    observerVector().append(observer);
+}
+
+void WorkerScriptController::removeObserver(WebKit::WebWorkerScriptObserver* observer)
+{
+    if (WebCore::WorkerThread::workerThreadCount() > 0)
+      return;
+
+    Vector<WebKit::WebWorkerScriptObserver*>& observers = observerVector();
+    size_t pos = observers.find(observer);
+    if (pos != notFound)
+        observers.remove(pos);
+}
+
+void WorkerScriptController::notifyDidCreateWorkerScriptContext()
+{
+    const Vector<WebKit::WebWorkerScriptObserver*>& observers = observerVector();
+    for (Vector<WebKit::WebWorkerScriptObserver*>::const_iterator i = observers.begin(); i != observers.end(); ++i)
+        (*i)->didCreateWorkerScriptContext(WebKit::WebWorkerRunLoop(&m_workerContext->thread()->runLoop()), m_workerContext->url(), m_context.get());
+}
+
+void WorkerScriptController::notifyWillReleaseWorkerScriptContext()
+{
+    const Vector<WebKit::WebWorkerScriptObserver*>& observers = observerVector();
+    for (Vector<WebKit::WebWorkerScriptObserver*>::const_iterator i = observers.begin(); i != observers.end(); ++i)
+        (*i)->willReleaseWorkerScriptContext(WebKit::WebWorkerRunLoop(&m_workerContext->thread()->runLoop()), m_workerContext->url(), m_context.get());
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(WORKERS)
Index: Source/WebCore/bindings/v8/WorkerScriptController.h
===================================================================
--- Source/WebCore/bindings/v8/WorkerScriptController.h	(revision 0)
+++ Source/WebCore/bindings/v8/WorkerScriptController.h	(working copy)
@@ -40,6 +40,10 @@
 #include <wtf/Threading.h>
 #include <wtf/text/TextPosition.h>
 
+namespace WebKit {
+class WebWorkerScriptObserver;
+}
+
 namespace WebCore {
 
     class ScriptSourceCode;
@@ -95,10 +99,17 @@ namespace WebCore {
         // Returns a local handle of the context.
         v8::Local<v8::Context> context() { return v8::Local<v8::Context>::New(m_context.get()); }
 
+        // Add or remove an observer. Can only be called while no WebWorkers exist.
+        static void addObserver(WebKit::WebWorkerScriptObserver*);
+        static void removeObserver(WebKit::WebWorkerScriptObserver*);
+
     private:
         bool initializeContextIfNeeded();
         void disposeContext();
 
+        void notifyDidCreateWorkerScriptContext();
+        void notifyWillReleaseWorkerScriptContext();
+
         WorkerContext* m_workerContext;
         v8::Isolate* m_isolate;
         ScopedPersistent<v8::Context> m_context;
Index: Source/WebCore/workers/WorkerRunLoop.cpp
===================================================================
--- Source/WebCore/workers/WorkerRunLoop.cpp	(revision 0)
+++ Source/WebCore/workers/WorkerRunLoop.cpp	(working copy)
@@ -88,10 +88,21 @@ private:
     bool m_defaultMode;
 };
 
+static void wakeup_callback(uv_async_t* handle, int status) {
+    // do nothing, just make libuv exit loop.
+}
+
+static void timer_callback(uv_timer_t* timer, int status) {
+    uv_async_t* handle = static_cast<uv_async_t*>(timer->data);
+    *static_cast<bool*>(handle->data) = true; // timer_called = true;
+    uv_async_send(handle);
+}
+
 WorkerRunLoop::WorkerRunLoop()
     : m_sharedTimer(adoptPtr(new WorkerSharedTimer))
     , m_nestedCount(0)
     , m_uniqueId(0)
+    , m_loop(NULL)
 {
 }
 
@@ -128,12 +139,62 @@ private:
 
 void WorkerRunLoop::run(WorkerContext* context)
 {
+    // Init in new thread.
+    m_loop = uv_default_loop();
+    uv_async_init(m_loop, &m_wakeup_event, wakeup_callback);
+
+    // Timer to catch m_sharedTimer.
+    bool timer_called = false;
+    uv_timer_t timer;
+    timer.data = &m_wakeup_event;
+    m_wakeup_event.data = &timer_called;
+    uv_timer_init(m_loop, &timer);
+
+    // Make uv_run_once wake up when running for the first time.
+    uv_async_send(&m_wakeup_event);
+
     RunLoopSetup setup(*this);
     ModePredicate modePredicate(defaultMode());
-    MessageQueueWaitResult result;
+    MessageQueueWaitResult result = MessageQueueTimeout;
     do {
-        result = runInMode(context, modePredicate, WaitForMessage);
+        if (m_sharedTimer->isActive()) {
+            double span = (m_sharedTimer->fireTime() - currentTime()) * 1000.;
+            // The timer in libuv tends to fire a bit earlier than the original
+            // pthread condition timer, which would cause many empty loop when
+            // nearing end, so making interval a bit longer seems to be a good
+            // idea, the 3ms is choosen via testing between many numbers.
+            span += 3.;
+            if (span <= 0.) {
+                if (!context->isClosing())
+                    m_sharedTimer->fire();
+            } else {
+                uv_timer_start(&timer, timer_callback, span, 0);
+            }
+        }
+
+        uv_run_once(m_loop);
+
+        if (uv_is_active(reinterpret_cast<uv_handle_t*>(&timer)))
+            uv_timer_stop(&timer);
+
+        if (timer_called) {
+            timer_called = false;
+            if (!context->isClosing())
+                m_sharedTimer->fire();
+        }
+
+        if (m_messageQueue.isEmpty())
+            continue;
+
+        result = runInMode(context, modePredicate, DontWaitForMessage);
     } while (result != MessageQueueTerminated);
+
+    // Run until uv quits.
+    uv_unref(reinterpret_cast<uv_handle_t*>(&m_wakeup_event));
+    uv_run(m_loop);
+
+    // Cleanup.
+    uv_loop_delete(m_loop);
     runCleanupTasks(context);
 }
 
@@ -168,8 +229,6 @@ MessageQueueWaitResult WorkerRunLoop::runInMode(WorkerContext* context, const Mo
         break;
 
     case MessageQueueTimeout:
-        if (!context->isClosing())
-            m_sharedTimer->fire();
         break;
     }
 
@@ -203,6 +262,9 @@ void WorkerRunLoop::postTask(PassOwnPtr<ScriptExecutionContext::Task> task)
 
 void WorkerRunLoop::postTaskForMode(PassOwnPtr<ScriptExecutionContext::Task> task, const String& mode)
 {
+    if (m_loop)
+        uv_async_send(&m_wakeup_event);
+
     m_messageQueue.append(Task::create(task, mode.isolatedCopy()));
 }
 
Index: Source/WebCore/workers/WorkerRunLoop.h
===================================================================
--- Source/WebCore/workers/WorkerRunLoop.h	(revision 0)
+++ Source/WebCore/workers/WorkerRunLoop.h	(working copy)
@@ -38,6 +38,8 @@
 #include <wtf/OwnPtr.h>
 #include <wtf/PassOwnPtr.h>
 
+#include "../../../../node/deps/uv/include/uv.h"
+
 namespace WebCore {
 
     class ModePredicate;
@@ -94,6 +96,9 @@ namespace WebCore {
         OwnPtr<WorkerSharedTimer> m_sharedTimer;
         int m_nestedCount;
         unsigned long m_uniqueId;
+
+        uv_loop_t* m_loop;
+        uv_async_t m_wakeup_event;
     };
 
 } // namespace WebCore
Index: Source/WebKit/chromium/public/WebWorkerInfo.h
===================================================================
--- Source/WebKit/chromium/public/WebWorkerInfo.h	(revision 0)
+++ Source/WebKit/chromium/public/WebWorkerInfo.h	(working copy)
@@ -35,9 +35,15 @@
 
 namespace WebKit {
 
+class WebWorkerScriptObserver;
+
 class WebWorkerInfo {
 public:
     WEBKIT_EXPORT static unsigned dedicatedWorkerCount();
+
+    // Add or remove an observer. Can only be called while no WebWorkers exist.
+    WEBKIT_EXPORT static void addScriptObserver(WebWorkerScriptObserver*);
+    WEBKIT_EXPORT static void removeScriptObserver(WebWorkerScriptObserver*);
 };
 
 }
Index: Source/WebKit/chromium/src/WebWorkerInfo.cpp
===================================================================
--- Source/WebKit/chromium/src/WebWorkerInfo.cpp	(revision 0)
+++ Source/WebKit/chromium/src/WebWorkerInfo.cpp	(working copy)
@@ -31,6 +31,7 @@
 #include "config.h"
 #include "WebWorkerInfo.h"
 
+#include "WorkerScriptController.h"
 #include "WorkerThread.h"
 
 namespace WebKit {
@@ -40,4 +41,14 @@ unsigned WebWorkerInfo::dedicatedWorkerCount()
     return WebCore::WorkerThread::workerThreadCount();
 }
 
+void WebWorkerInfo::addScriptObserver(WebWorkerScriptObserver* observer)
+{
+    WebCore::WorkerScriptController::addObserver(observer);
+}
+
+void WebWorkerInfo::removeScriptObserver(WebWorkerScriptObserver* observer)
+{
+    WebCore::WorkerScriptController::removeObserver(observer);
+}
+
 }
